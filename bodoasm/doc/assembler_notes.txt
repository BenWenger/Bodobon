
SCOPE
======================
- Namespaces can be defined and nested
- Top level labels define the scope for local symbols
- Local symbols start with a dot .
- dash - is scope qualifier for non-local symbols
- To access global scope, prefix with -

        Label:                  ; (1)
        #ns   ns                ; Entering 'ns' namespace
            Label:              ; (2)
                .Label:         ; (3)
                    JMP Label   ;  -> 2
                    JMP .Label  ;  -> 3
                    JMP -Label  ;  -> 1
        #endns                  ; exiting 'ns' namespace
        JMP Label               ;  -> 1
        JMP ns-Label            ;  -> 2
        JMP ns-Label.Label      ;  -> 3
        JMP -Label              ;  -> 1

Nameless labels effectively have local scope, but are completely inaccessible
from outside their Top-level label

        Foo:
            :                   ; (1)
                JMP :-          ; -> 1
                JMP :+          ; -> 2
            :                   ; (2)
                JMP :+          ; error, (3) in Bar scope
        Bar:                    
            :                   ; (3)
                JMP :-          ; (3)
                JMP :--         ; error, (2) is in Foo scope
                
Nameless and local don't need a top level label, but it generally makes them
easier to use

        .local                  ; (1)
        :                       ; (2)
            JMP :-              ; -> 2
        Foo:
            JMP :-              ; error, (2) is in global scope
            JMP .local          ; error, (1) is in global scope
            JMP -.local         ; -> 1
            
            
            
======================
Expressions
======================
    Integer operator precedence (highest at top, lowest at bottom):
    
        ()                              (parenthesis)
        [unary operators (see below)]
        *   /   %
        +   -
        <<  >>
        <   <=  >   >=
        ==  !=
        &
        ^
        |
        &&
        ||
        
    The only string operator is + which concatenates two strings, but there might also be
    surrounding parens.
    
    Unary operators all have the same precedence, but are right-to-left associative:
        ?defined    -   !   ~   <   >   ^   <>
    
    Other things:
        ?pc    = constant being the current PC
        
=======================
Comments
=======================
    Single line comments begin with a semicolon                     ; example comment
    Block comments have a semicolon, dash, and reversed closing     ;- example comment -;
    
    Since line breaks are part of command processing (addr mode matching must all be on the same line),
a block comment that spans multiple lines will not count as a line break.
    
    
    
=======================
Directives
=======================
    List is incomplete.  I'll add more later
    
    
#org    addr,   offset, [size], [fill]
    - addr is the address (mandatory)
    - offset is the binary file offset to place this code
    - size is the maximum size allowed for this block.  If negative, it specifies
        an upper-bound address instead of a size
    - fill is the value to fill output with if the output was less than the
        desired size

#rebase     addr
#endrebase
    - For relocatable code (does anyone actually use this?)
    - Changes the org addr but not output offset.  Ending reverts org
        addr to what it would be after all that binary was output
    - Throw error if #org happens before #endrebase

#if     expr
#elif   expr
#else
#endif
    - for conditional compilation.  'Expr' must be able to be evaluated on
        first pass.  A value of Zero is false, any other value is true
        
#macro  name, [args...]
#endmacro
    - define a macro with name 'name', invoked with '!name'.
    - args can be any number of optional arguments to be passed in
    - macros operate on copy/paste semantics.  IE they are not parsed when first declared, rather
        they are merely lexed and then injected into their invokations with parameters being replaced
        with whatever was passed in
    - no nesting macro definitions!!!!