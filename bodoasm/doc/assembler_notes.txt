
SCOPE
======================
    A global label defines your current scope.
    Local symbols are prefixed with a dot (.) and are local to your current scope.
    Local symbols in other scopes can be accessed by giving the full scope qualifier.
    Example:
    
        MyCode:
            .MySym = 1
            .LocalLabel:
                LDA .MySym          ; OK
            
        NewScope:
            LDA .MySym              ; error, no .MySym in this scope
            LDA MyCode.MySym        ; OK
            JMP .LocalLabel         ; error
            JMP MyCode.LocalLabel   ; OK
            
    Nameless labels are local to the current scope.  Nameless labels outside your current
    scope cannot be accessed at all.
    
    
    In macros:
    
    Macros have their own scope.  Global symbols defined in a macro are exported normally (be
careful!!!).  However, a global label defined in a macro does not change your scope until the
macro exits and you return to your "true" scope.

    Local symbols are local to the macro.  However you can export local symbols to your true
scope (and access existing locals in your true scope) by prefixing them with the @ operator:

    (TODO come up with an example for this)
            
            
======================
Expressions
======================
    Integer operator precedence (highest at top, lowest at bottom):
    
        ()                              (parenthesis)
        [unary operators (see below)]
        *   /   %
        +   -
        <<  >>
        <   <=  >   >=
        ==  !=
        &
        ^
        |
        &&
        ||
        
    The only string operator is + which concatenates two strings, but there might also be
    surrounding parens.
    
    Unary operators all have the same precedence, but are right-to-left associative:
        ?defined    -   !   ~   <   >   ^   <>
    
    Other things:
        ?pc    = constant being the current PC
        
=======================
Comments
=======================
    Single line comments begin with a semicolon                     ; example comment
    Block comments have a semicolon, dash, and reversed closing     ;- example comment -;
    
    Since line breaks are part of command processing (addr mode matching must all be on the same line),
a block comment that spans multiple lines will not count as a line break.
    
    
    
=======================
Directives
=======================
    List is incomplete.  I'll add more later
    
    
#org    addr,   offset, [size], [fill]
    - addr is the address (mandatory)
    - offset is the binary file offset to place this code
    - size is the maximum size allowed for this block.  If negative, it specifies
        an upper-bound address instead of a size
    - fill is the value to fill output with if the output was less than the
        desired size

#rebase     addr
#endrebase
    - For relocatable code (does anyone actually use this?)
    - Changes the org addr but not output offset.  Ending reverts org
        addr to what it would be after all that binary was output
    - Throw error if #org happens before #endrebase

#if     expr
#elif   expr
#else
#endif
    - for conditional compilation.  'Expr' must be able to be evaluated on
        first pass.  A value of Zero is false, any other value is true
        
#macro  name, [args...]
#endmacro
    - define a macro with name 'name', invoked with '!name'.
    - args can be any number of optional arguments to be passed in
    - macros operate on copy/paste semantics.  IE they are not parsed when first declared, rather
        they are merely lexed and then injected into their invokations with parameters being replaced
        with whatever was passed in
    - no nesting macro definitions!!!!